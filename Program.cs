using System;
using System.Drawing;
using SlimDX;
using SlimDX.Direct3D11;
using SlimDX.DXGI;
using SlimDX.Windows;
using SlimDX.D3DCompiler;
using Device = SlimDX.Direct3D11.Device;

namespace Micro_Architecture
{
    class Program
    {
        static Device device;
        static SwapChain swapChain;
        static InputLayout Layout;
        static RenderTargetView renderView;
        static SlimDX.Direct3D11.Buffer quadVertices;
        static Effect effect;
        static ComputeShader particlePointOutputCS;
        static ComputeShader pressureOutputCS;
        static ComputeShader updateParticlePositionsCS;
        static EffectTechnique technique;
        static EffectPass pass;
        static Vector2 scale;
        static Vector2 pos;
        static Texture2D renderParticalTexture;
        static ShaderResourceView renderParticalSRV;
        static UnorderedAccessView renderParticalUAV;
        static Texture2D renderGridTexture;
        static ShaderResourceView renderGridSRV;
        static UnorderedAccessView renderGridUAV;
        static Texture3D pressureTexture;
        static UnorderedAccessView pressureUAV;
        static ShaderResourceView pressureSRV;
        static SlimDX.Direct3D11.Buffer particleBufferA;
        static SlimDX.Direct3D11.Buffer particleBufferB;
        static ShaderResourceView particleBufferSRVA;
        static ShaderResourceView particleBufferSRVB;
        static UnorderedAccessView particleBufferUAVA;
        static UnorderedAccessView particleBufferUAVB;
        static SlimDX.Direct3D11.Buffer physicsConstantBuffer;
        const bool MainRenderParticles = false;

        static bool leftDown = false;
        
        // We store particles in a grid of boxes, this
        // gives us a global way to control it
        const int NumBoxesPerAxis = 128;
        const int NumBoxesTotal = NumBoxesPerAxis * NumBoxesPerAxis * NumBoxesPerAxis;

        static void Main(string[] args)
        {
            var form = InitD3D();
            InitRAWInput();
            InitRenderTextureAndVB();
            InitParticleBuffer();
            InitPressureTexture();

            MessagePump.Run(form, SimMain);
            
            quadVertices.Dispose();
            renderView.Dispose();
            device.Dispose();
            swapChain.Dispose();

        }

        /// <summary>
        /// The main loop function that gets called by the SlimDX message pump,
        /// specifically do a simulation update step then draw the result to the
        /// screen
        /// </summary>
        static void SimMain()
        {
            UpdateSimulationState();
            if (MainRenderParticles == true)
            {
                OutputParticlePositions();
            }
            else
            {
                OutputPressure();
            }
            DrawRenderTextureToScreen();
            SwapBuffers();

            swapChain.Present(0, PresentFlags.None);

            //System.Threading.Thread.Sleep(30);
        }

        // Do the calculations for the current timestep,
        // update positions and forces of particles
        private static void UpdateSimulationState()
        {
            device.ImmediateContext.ComputeShader.Set(updateParticlePositionsCS);
            device.ImmediateContext.ComputeShader.SetUnorderedAccessViews(
                new UnorderedAccessView[] { particleBufferUAVA, pressureUAV }, 0, 2);
            device.ImmediateContext.ComputeShader.SetShaderResource(particleBufferSRVB, 2);

            device.ImmediateContext.ComputeShader.SetConstantBuffer(physicsConstantBuffer, 0);

            device.ImmediateContext.ClearUnorderedAccessView(pressureUAV, new int[] { 0, 0, 0, 0 });

            device.ImmediateContext.Dispatch(NumBoxesTotal, 1, 1);

            device.ImmediateContext.ComputeShader.SetUnorderedAccessView(null, 0);
            device.ImmediateContext.ComputeShader.SetShaderResource(null, 2);
            device.ImmediateContext.ComputeShader.SetUnorderedAccessView(null, 1);
        }

        /// <summary>
        /// We now need to swap the buffers so that the input to the
        /// next timestep is the output from the last one
        /// </summary>
        private static void SwapBuffers()
        {
            var tempSRV = particleBufferSRVA;
            particleBufferSRVA = particleBufferSRVB;
            particleBufferSRVB = tempSRV;

            var tempUAV = particleBufferUAVA;
            particleBufferUAVA = particleBufferUAVB;
            particleBufferUAVB = tempUAV;
        }

        /// <summary>
        /// Draws a full screen quad with the texture generated by the simulation
        /// output stage
        /// </summary>
        static void DrawRenderTextureToScreen()
        {
            device.ImmediateContext.ClearRenderTargetView(renderView, Color.Black);

            device.ImmediateContext.InputAssembler.InputLayout = Layout;
            device.ImmediateContext.InputAssembler.PrimitiveTopology = PrimitiveTopology.TriangleList;
            device.ImmediateContext.InputAssembler.SetVertexBuffers(0, new VertexBufferBinding(quadVertices, 32, 0));

            if (MainRenderParticles)
            {
                effect.GetVariableByName("tx").AsResource().SetResource(renderParticalSRV);
            }
            else
            {
                effect.GetVariableByName("tx").AsResource().SetResource(renderGridSRV);
            }

            for (int i = 0; i < technique.Description.PassCount; ++i)
            {
                pass.Apply(device.ImmediateContext);
                device.ImmediateContext.Draw(6, 0);
            }

            effect.GetVariableByName("tx").AsResource().SetResource(null);
        }

        static void OutputPressure()
        {
            device.ImmediateContext.ComputeShader.Set(pressureOutputCS);
            device.ImmediateContext.ComputeShader.SetUnorderedAccessView(renderGridUAV, 0);
            device.ImmediateContext.ComputeShader.SetShaderResource(pressureSRV, 1);
            device.ImmediateContext.ClearUnorderedAccessView(renderGridUAV, new[] { 0.0f, 0.0f, 0.0f, 0.0f });

            device.ImmediateContext.Dispatch(NumBoxesPerAxis / 8, NumBoxesPerAxis / 8, 1);

            device.ImmediateContext.ComputeShader.SetUnorderedAccessView(null, 0);
            device.ImmediateContext.ComputeShader.SetShaderResource(null, 1);
        }

        static void OutputParticlePositions()
        {
            device.ImmediateContext.ComputeShader.Set(particlePointOutputCS);
            device.ImmediateContext.ComputeShader.SetUnorderedAccessView(renderParticalUAV, 0);
            device.ImmediateContext.ComputeShader.SetShaderResource(particleBufferSRVB, 2);
            device.ImmediateContext.ClearUnorderedAccessView(renderParticalUAV, new[] { 0.0f, 0.0f, 0.0f, 0.0f });

            device.ImmediateContext.Dispatch(NumBoxesTotal, 1, 1);

            device.ImmediateContext.ComputeShader.SetUnorderedAccessView(null, 0);
            device.ImmediateContext.ComputeShader.SetShaderResource(null, 1);
        }

        static SlimDX.Windows.RenderForm InitD3D()
        {
            var form = new RenderForm("Solar simulation");

            form.Width = 1920;
            form.Height = 1080;

            var desc = new SwapChainDescription()
            {
                BufferCount = 1,
                ModeDescription = new ModeDescription(form.ClientSize.Width, form.ClientSize.Height, new Rational(60, 1), Format.R8G8B8A8_UNorm),
                IsWindowed = true,
                OutputHandle = form.Handle,
                SampleDescription = new SampleDescription(1, 0),
                SwapEffect = SwapEffect.Discard,
                Usage = Usage.RenderTargetOutput
            };

            Device.CreateWithSwapChain(DriverType.Hardware, DeviceCreationFlags.Debug, desc, out device, out swapChain);

            Factory factory = swapChain.GetParent<Factory>();
            factory.SetWindowAssociation(form.Handle, WindowAssociationFlags.IgnoreAll);

            Texture2D backBuffer = Texture2D.FromSwapChain<Texture2D>(swapChain, 0);
            renderView = new RenderTargetView(device, backBuffer);
            var bytecode = ShaderBytecode.CompileFromFile("MiniTri.fx", "fx_5_0", ShaderFlags.None, EffectFlags.None);
            effect = new Effect(device, bytecode);
            var csBytecode = ShaderBytecode.CompileFromFile("SimulationComputeShaders.hlsl", "OutputParticlePoints", "cs_5_0", ShaderFlags.None, EffectFlags.None);
            particlePointOutputCS = new ComputeShader(device, csBytecode);
            var pressureOutputBytecode = ShaderBytecode.CompileFromFile("SimulationComputeShaders.hlsl", "OutputPressures", "cs_5_0", ShaderFlags.None, EffectFlags.None);
            pressureOutputCS = new ComputeShader(device, pressureOutputBytecode);
            var inputBytecode = ShaderBytecode.CompileFromFile("SimulationComputeShaders.hlsl", "UpdateParticelPositions", "cs_5_0", ShaderFlags.None, EffectFlags.None);
            updateParticlePositionsCS = new ComputeShader(device, inputBytecode);
            technique = effect.GetTechniqueByIndex(0);
            pass = technique.GetPassByIndex(0);

            RasterizerStateDescription rsd = new RasterizerStateDescription()
            {
                CullMode = CullMode.None,
                DepthBias = 0,
                DepthBiasClamp = 0.0f,
                FillMode = FillMode.Solid,
                IsAntialiasedLineEnabled = false,
                IsDepthClipEnabled = false,
                IsFrontCounterclockwise = false,
                IsMultisampleEnabled = false,
                IsScissorEnabled = false,
                SlopeScaledDepthBias = 0.0f
            };

            RasterizerState rs = RasterizerState.FromDescription(device, rsd);
            device.ImmediateContext.Rasterizer.State = rs;

            device.ImmediateContext.OutputMerger.SetTargets(renderView);
            device.ImmediateContext.Rasterizer.SetViewports(new Viewport(0, 0, form.ClientSize.Width, form.ClientSize.Height, 0.0f, 1.0f));

            scale = new Vector2(1000.0f / 1920.0f, 1000.0f / 1080.0f);
            pos = new Vector2(0.0f, 0.0f);

            /*bytecode.Dispose();
            effect.Dispose();
            backBuffer.Dispose();*/
            
            InitPhysicsConstantBuffer();

            return form;
        }

        private static void InitPressureTexture()
        {
            Texture3DDescription pressureTexDesc = new Texture3DDescription()
            {
                BindFlags = BindFlags.ShaderResource | BindFlags.UnorderedAccess,
                CpuAccessFlags = CpuAccessFlags.None,
                Depth = NumBoxesPerAxis,
                Format = Format.R32_UInt,
                Height = NumBoxesPerAxis,
                MipLevels = 1,
                OptionFlags = ResourceOptionFlags.None,
                Usage = ResourceUsage.Default,
                Width = NumBoxesPerAxis
            };

            pressureTexture = new Texture3D(device, pressureTexDesc);
            pressureUAV = new UnorderedAccessView(device, pressureTexture);
            pressureSRV = new ShaderResourceView(device, pressureTexture);
        }

        static void InitRAWInput()
        {
            SlimDX.RawInput.Device.RegisterDevice(SlimDX.Multimedia.UsagePage.Generic, SlimDX.Multimedia.UsageId.Mouse, SlimDX.RawInput.DeviceFlags.None);
            SlimDX.RawInput.Device.MouseInput += new System.EventHandler<SlimDX.RawInput.MouseInputEventArgs>(Device_MouseInput);
        }

        static void InitPhysicsConstantBuffer()
        {
            var physicsBufferSizeInBytes = 64;
            var desc = new BufferDescription()
            {
                BindFlags = BindFlags.ConstantBuffer,
                CpuAccessFlags = CpuAccessFlags.None,
                OptionFlags = ResourceOptionFlags.None,
                SizeInBytes = physicsBufferSizeInBytes,
                StructureByteStride = 0,
                Usage = ResourceUsage.Default
            };

            var data = new DataStream(physicsBufferSizeInBytes, true, true);
            data.Write(MathsAndPhysics.TimestepInYears);
            data.Write(MathsAndPhysics.DenseCoreSizeMilliPC / 2.0f);
            data.Write(MathsAndPhysics.DenseCoreSizeMilliPC);
            data.Write((float)NumBoxesPerAxis);

            data.Position = 0;

            physicsConstantBuffer = new SlimDX.Direct3D11.Buffer(device, data, desc);
        }

        static void Device_MouseInput(object sender, SlimDX.RawInput.MouseInputEventArgs e)
        {
            if ((e.ButtonFlags & SlimDX.RawInput.MouseButtonFlags.LeftDown) == SlimDX.RawInput.MouseButtonFlags.LeftDown)
                leftDown = true;
            if ((e.ButtonFlags & SlimDX.RawInput.MouseButtonFlags.LeftUp) == SlimDX.RawInput.MouseButtonFlags.LeftUp)
                leftDown = false;

            if (leftDown)
            {
                pos.X += e.X * 3.0f / 1920.0f;
                pos.Y -= e.Y * 3.0f / 1080.0f;
            }

            scale.X -= e.WheelDelta / 1920.0f;
            scale.Y -= e.WheelDelta / 1080.0f;

            if (scale.X < 0.0f)
            {
                scale.X = 100.0f / 1920.0f;
                scale.Y = 100.0f / 1080.0f;
            }
        }

        /// <summary>
        /// Build the buffer that will hold the particles, a 3d grid of
        /// boxes
        /// </summary>
        static void InitParticleBuffer()
        {
            var rand = MathsAndPhysics.Random;
            // Size calculations
            const int particleSize = 3 * sizeof(float) *  2; // float3 position + float3 velocity
            const int particlesPerBox = 8;
            const int numBoxes = NumBoxesPerAxis * NumBoxesPerAxis * NumBoxesPerAxis;
            const int numParticles = numBoxes * particlesPerBox;
            const int bufferSize = numParticles* particleSize;

            // Create a stream and fill it with data
            var streamB = new DataStream(bufferSize, true, true);

            MathsAndPhysics.AxisOfRotation = MathsAndPhysics.GenerateRandomVec3();
            MathsAndPhysics.AxisOfRotation.Normalize();

            for (int particleId = 0; particleId < numParticles; particleId++)
            {
                var pos = MathsAndPhysics.GenerateRandomVec3();
                pos *= MathsAndPhysics.DenseCoreSizeMilliPC / 2.0f;
                pos.X *= 10;
                pos.Y += pos.X / 2;
                pos /= 10.0f; // small box for testing
                pos.X -= MathsAndPhysics.DenseCoreSizeMilliPC / 3.0f;
                streamB.Write(pos);

                var direction = Vector3.Cross(pos, MathsAndPhysics.AxisOfRotation);
                direction.Normalize();
                float speed = 2.0f * (float)Math.PI * MathsAndPhysics.DenseCoreSizeMilliPC * MathsAndPhysics.AngularSpeedMicroRadsPerYear / 1000000.0f;
                var velocityMilliPCPerYear = direction * speed;
                var velocity = Vector3.UnitX * 2 + Vector3.UnitY + (MathsAndPhysics.GenerateRandomVec3() * 0.1f);
                streamB.Write(velocity * 50);
                //streamB.Write(velocityMilliPCPerYear);
            }
            // Have to reset the stream or buffer creation will try to read from
            // the end
            streamB.Position = 0;
            
            // Create the buffer and fill it with data
            BufferDescription desc = new BufferDescription()
            {
                BindFlags = BindFlags.UnorderedAccess | BindFlags.ShaderResource,
                CpuAccessFlags = CpuAccessFlags.None,
                OptionFlags = ResourceOptionFlags.StructuredBuffer,
                SizeInBytes = bufferSize,
                StructureByteStride = particleSize,
                Usage = ResourceUsage.Default
            };


            var streamA = new DataStream(bufferSize, true, true);

            particleBufferA = new SlimDX.Direct3D11.Buffer(device, streamA, desc);
            particleBufferSRVA = new ShaderResourceView(device, particleBufferA);
            particleBufferUAVA = new UnorderedAccessView(device, particleBufferA);

            particleBufferB = new SlimDX.Direct3D11.Buffer(device, streamB, desc);
            particleBufferSRVB = new ShaderResourceView(device, particleBufferB);
            particleBufferUAVB = new UnorderedAccessView(device, particleBufferB);
        }

        /// <summary>
        /// Create the render texture that will display the state of the simulation,
        /// also the VB for drawing a full screen quad, and the resource views
        /// </summary>
        static void InitRenderTextureAndVB()
        {

            const int vertexSizeInBytes = 32;

            Layout = new InputLayout(device, pass.Description.Signature, new[] {
                new InputElement("POSITION", 0, Format.R32G32B32A32_Float, 0, 0),
                new InputElement("TEXCOORD", 0, Format.R32G32B32A32_Float, 16, 0)
            });
            
            var stream = new DataStream(vertexSizeInBytes * 6, true, true);
            
            stream.Write(new Vector4(-1.0f, -1.0f, 0.5f, 1.0f));
            stream.Write(new Vector4( 0.0f,  1.0f, 0.5f, 1.0f));
            stream.Write(new Vector4(-1.0f,  1.0f, 0.5f, 1.0f));
            stream.Write(new Vector4( 0.0f,  0.0f, 0.5f, 1.0f));
            stream.Write(new Vector4( 1.0f, -1.0f, 0.5f, 1.0f));
            stream.Write(new Vector4( 1.0f,  1.0f, 0.5f, 1.0f));

            stream.Write(new Vector4( 1.0f,  1.0f, 0.5f, 1.0f));
            stream.Write(new Vector4( 1.0f,  0.0f, 0.5f, 1.0f));
            stream.Write(new Vector4(-1.0f,  1.0f, 0.5f, 1.0f));
            stream.Write(new Vector4( 0.0f,  0.0f, 0.5f, 1.0f));
            stream.Write(new Vector4( 1.0f, -1.0f, 0.5f, 1.0f));
            stream.Write(new Vector4( 1.0f,  1.0f, 0.5f, 1.0f));
            stream.Position = 0;

            quadVertices = new SlimDX.Direct3D11.Buffer(device, stream, new BufferDescription()
            {
                BindFlags = BindFlags.VertexBuffer,
                CpuAccessFlags = CpuAccessFlags.None,
                OptionFlags = ResourceOptionFlags.None,
                SizeInBytes = 6 * vertexSizeInBytes,
                Usage = ResourceUsage.Default
            });

            stream.Dispose();

            Texture2DDescription renderTexDesc = new Texture2DDescription()
            {
                ArraySize = 1,
                BindFlags = BindFlags.ShaderResource | BindFlags.UnorderedAccess,
                CpuAccessFlags = CpuAccessFlags.None,
                Format = Format.R8G8B8A8_UNorm,
                Height = 720,
                Width = 1280,
                MipLevels = 1,
                OptionFlags = ResourceOptionFlags.None,
                SampleDescription = new SampleDescription()
                {
                    Count = 1,
                    Quality = 0,
                },
                Usage = ResourceUsage.Default
            };
            renderParticalTexture = new Texture2D(device, renderTexDesc);
            renderParticalSRV = new ShaderResourceView(device, renderParticalTexture);
            renderParticalUAV = new UnorderedAccessView(device, renderParticalTexture);

            renderTexDesc.Width = NumBoxesPerAxis;
            renderTexDesc.Height = NumBoxesPerAxis;

            renderGridTexture = new Texture2D(device, renderTexDesc);
            renderGridUAV = new UnorderedAccessView(device, renderGridTexture);
            renderGridSRV = new ShaderResourceView(device, renderGridTexture);
        }
    }
}
